name: Windows RDP Setup

on:
  workflow_dispatch:
    inputs:
      region:
        description: 'Select Ngrok Tunnel Region'
        required: true
        type: choice
        options:
        - "us"
        - "eu"
        - "ap"
        - "au"
        - "sa"
        - "jp"
        - "in"
        default: 'in'
      timeout:
        description: 'Session Timeout (minutes, max 360)'
        required: true
        type: string
        default: '360'

env:
  USERNAME: "Ashik"
  PASSWORD: "AshiksBeastServer2006"
  PC_NAME: "Ashik-PC"

jobs:
  rdp-session:
    runs-on: windows-latest
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout) }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure RDP & User
        shell: pwsh
        run: |
          # Enable RDP
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          netsh advfirewall firewall add rule name="RDP" dir=in action=allow protocol=TCP localport=3389
          Restart-Service -Name TermService -Force
          
          # Create user with fixed password
          $securePass = ConvertTo-SecureString "$env:PASSWORD" -AsPlainText -Force
          New-LocalUser -Name "$env:USERNAME" -Password $securePass -FullName "$env:USERNAME"
          Add-LocalGroupMember -Group "Administrators" -Member "$env:USERNAME"
          
          # Set computer name (remove spaces and special characters)
          $validName = $env:PC_NAME -replace '[^a-zA-Z0-9-]', '-'
          Rename-Computer -NewName $validName -Force
          Write-Host "Computer name set to: $validName"

      - name: Install Virtual Sound Card and Enable Audio
        shell: pwsh
        run: |
          echo "Installing VB-CABLE Virtual Audio Device using Chocolatey..."
          choco install vb-cable -y --force
          
          echo "Enabling Windows Audio Services..."
          Set-Service -Name Audiosrv -StartupType Automatic -PassThru | Start-Service
          Set-Service -Name AudioEndpointBuilder -StartupType Automatic -PassThru | Start-Service
          
          echo "Configuring Group Policy for RDP Audio Redirection..."
          Set-ItemProperty -Path 'HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services' -Name "fEnableAudioCapture" -Value 1 -Type DWord -Force
          Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "fDisableAudioCapture" -Value 0 -Type DWord -Force
          
          echo "Audio setup is complete."

      - name: Install Google Chrome and Set as Default
        shell: pwsh
        run: |
          # Install Chrome using offline installer for reliability
          $chromeInstaller = "chrome_installer.exe"
          $downloadUrl = "https://dl.google.com/chrome/install/latest/chrome_installer.exe"
          
          # Download Chrome installer
          try {
              Invoke-WebRequest -Uri $downloadUrl -OutFile $chromeInstaller -ErrorAction Stop
              Write-Host "Chrome installer downloaded successfully"
          } catch {
              Write-Warning "Failed to download Chrome installer: $($_.Exception.Message)"
              Write-Host "Trying alternate download method..."
              
              # Create batch script without here-string
              $batchContent = @'
@echo off
start microsoft-edge:https://www.google.com/chrome/
timeout /t 10
exit
'@
              $batchContent | Out-File -FilePath "download_chrome.cmd" -Encoding ascii
              Start-Process -FilePath "download_chrome.cmd" -Wait
          }
          
          # Install Chrome
          if (Test-Path $chromeInstaller) {
              Write-Host "Installing Google Chrome..."
              Start-Process -FilePath $chromeInstaller -ArgumentList "/silent /install" -Wait
              
              # Wait for Chrome to be properly installed
              Start-Sleep -Seconds 30
              
              # Set Chrome as default browser using registry
              $chromePath = "${env:ProgramFiles(x86)}\Google\Chrome\Application\chrome.exe"
              if (Test-Path $chromePath) {
                  # Set Chrome as default for HTTP and HTTPS
                  reg add "HKCU\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice" /v ProgId /d "ChromeHTML" /f
                  reg add "HKCU\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\https\UserChoice" /v ProgId /d "ChromeHTML" /f
                  Write-Host "Google Chrome set as default browser"
              } else {
                  Write-Warning "Chrome installation may have failed, path not found: $chromePath"
              }
          } else {
              Write-Warning "Chrome installer not found, trying direct download from web"
              # Final fallback - use the standard online installer
              $webClient = New-Object System.Net.WebClient
              $webClient.DownloadFile("https://www.google.com/chrome/", "chrome_online_installer.exe")
              Start-Process -FilePath "chrome_online_installer.exe" -ArgumentList "/silent /install" -Wait
          }

      - name: Set Custom Wallpaper
        shell: pwsh
        run: |
          $wallpaperUrl = "https://4kwallpapers.com/images/wallpapers/windows-11-dark-mode-blue-stock-official-3840x2160-5630.jpg"
          $wallpaperPath = "$env:TEMP\wallpaper.jpg"
          
          try {
            # Download wallpaper
            Invoke-WebRequest -Uri $wallpaperUrl -OutFile $wallpaperPath -ErrorAction Stop
            
            # Set wallpaper using SystemParametersInfo
            Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
public class Wallpaper {
    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);
}
"@
            [Wallpaper]::SystemParametersInfo(0x0014, 0, $wallpaperPath, 0x01) | Out-Null
            Write-Host "Wallpaper set successfully"
          } catch {
            Write-Warning "Failed to set wallpaper: $($_.Exception.Message)"
            # Fallback: Use a solid color
            Write-Host "Using fallback solid color background"
            Set-ItemProperty -Path 'HKCU:\Control Panel\Colors' -Name Background -Value "0 78 152" -Type String
          }

      - name: Install jq
        shell: pwsh
        run: |
          # Create the directory first, then download jq
          New-Item -ItemType Directory -Force -Path "C:\ProgramData\chocolatey\bin" | Out-Null
          Invoke-WebRequest -Uri "https://github.com/stedolan/jq/releases/download/jq-1.6/jq-win64.exe" -OutFile "C:\ProgramData\chocolatey\bin\jq.exe"
          # Add to PATH for current session
          $env:Path += ";C:\ProgramData\chocolatey\bin"

      - name: Setup Ngrok Tunnel
        shell: pwsh
        run: |
          $REGION = "${{ github.event.inputs.region }}"
          $AUTH_TOKEN = "${{ secrets.NGROK_AUTH_TOKEN }}"
          $NGROK_LOG = "ngrok.log"
          $CONFIG_FILE = "ngrok.yml"
          $PORT = "3389"

          # Create ngrok configuration file
          "version: `"2`"" | Out-File -FilePath $CONFIG_FILE -Encoding ascii
          "authtoken: $AUTH_TOKEN" | Out-File -FilePath $CONFIG_FILE -Encoding ascii -Append
          "region: $REGION" | Out-File -FilePath $CONFIG_FILE -Encoding ascii -Append

          Write-Host "Downloading ngrok..."
          # Manual download for Windows
          Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile "ngrok.zip"
          Expand-Archive -Path "ngrok.zip" -DestinationPath . -Force

          Write-Host "Starting ngrok tunnel on port $PORT..."
          Start-Process -NoNewWindow -FilePath ".\ngrok.exe" -ArgumentList "tcp $PORT --config $CONFIG_FILE --log $NGROK_LOG"

          Write-Host "Waiting for ngrok to start..."
          Start-Sleep -Seconds 15
          
          $tunnelUrl = $null
          $attempts = 0
          while ($attempts -lt 5 -and -not $tunnelUrl) {
              try {
                  $tunnelInfo = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -ErrorAction Stop
                  $tunnelUrl = $tunnelInfo.tunnels[0].public_url
              } catch {
                  Write-Host "Attempt $($attempts + 1): Tunnel not ready yet, waiting..."
                  Start-Sleep -Seconds 5
              }
              $attempts++
          }

          if (-not $tunnelUrl) {
              Write-Error "Failed to get ngrok tunnel info after multiple attempts."
              if (Test-Path $NGROK_LOG) {
                  Write-Host "Ngrok log content:"
                  Get-Content $NGROK_LOG
              } else {
                  Write-Host "No ngrok log found"
              }
              exit 1
          }

          $tunnelUrl = $tunnelUrl -replace "tcp://", ""
          $tunnelParts = $tunnelUrl -split ":"
          $RDP_ADDRESS = $tunnelParts[0]
          $RDP_PORT = $tunnelParts[1]
          
          "RDP_ADDRESS=$RDP_ADDRESS" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "RDP_PORT=$RDP_PORT" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "Tunnel established successfully: $tunnelUrl"

      - name: Display Connection Details
        shell: pwsh
        run: |
          Write-Host "ðŸŽ¯ CONNECTION DETAILS ðŸŽ¯"
          Write-Host "=========================================="
          Write-Host "OS: Windows"
          Write-Host "Protocol: RDP (Use Remote Desktop Connection)"
          Write-Host "Port: 3389"
          Write-Host "Address: $env:RDP_ADDRESS"
          Write-Host "Port: $env:RDP_PORT"
          Write-Host "Username: $env:USERNAME"
          Write-Host "Password: $env:PASSWORD"
          Write-Host "PC Name: $env:PC_NAME"
          Write-Host "Default Browser: Google Chrome"
          Write-Host "=========================================="
          Write-Host "Connection string: $env:RDP_ADDRESS`:$env:RDP_PORT"

      - name: Keep Workflow Alive
        shell: pwsh
        run: |
          Write-Host "Remote desktop session is now active!"
          Write-Host "The workflow will remain running for ${{ github.event.inputs.timeout }} minutes."
          Write-Host "Press Ctrl+C in the workflow logs to terminate the session early."

          # Main loop to keep the workflow running
          $count = 0
          while ($true) {
              Write-Host "[$(Get-Date)] Session active - Address: $env:RDP_ADDRESS`:$env:RDP_PORT"
              Start-Sleep -Seconds 60
              $count++
          }